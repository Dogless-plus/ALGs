# 字符串算法

## 一、字符串排序

#### A.键索引计数法

思路：每个优先级设置开始位置，对于新数据更新这个开始位置。
稳定的，线性的。计数桶类似哈希桶。

```python
# coding =utf-8


def index_sort(data):
    values, weights = zip(*data)
    max_weight = max(weights)
    counter = [0] * (max_weight + 2)
    for value, weight in data:  # 计数器，放在后面一个位置上。每个位置对上一个优先级计数。
        counter[weight + 1] += 1
    for i in range(max_weight+1): # 在后面一位设置这一位（优先级）的上限，即后一位的开始位置
        counter[i+1] += counter[i]
    aux = [0] * len(data)
    for value, weight in data:
        aux[counter[weight]] = value  # 在可用位置处存入数据
        counter[weight] += 1  # 更新可用的开始位置
    print(aux)
    print(counter)


data = [('A', 2),
        ('B', 3),
        ('C', 3),
        ('D', 4),
        ('E', 1),
        ('F', 3),
        ('G', 4),
        ('H', 3),
        ('I', 1),
        ('J', 2),
        ('K', 2),
        ('L', 1),
        ('M', 2),
        ('N', 4),
        ('O', 3),
        ('P', 4),
        ('Q', 4),
        ('R', 2),
        ('S', 3),
        ('T', 4)]

index_sort(data)
```


#### B、字符串按低位排序

思路：利用**稳定的**键索引计数法进行排序，从低位到高位一位一位地排。

注意：计数桶用ASCII码的256个值就够了。一定要稳定，不然按位进行排序就可能出错了。线性复杂度。

应用：老式的卡片打孔机。车牌号排序。

```python
# coding=utf-8

class LSD:
    def __init__(self, data):
        self.data = data  # 浅引用
        self.N = len(data)
        self.S = len(data[0])
        self.R = 256  # 计数器的数量
        self.aux = [""] * self.N
        self.sort()

    def sort_one(self, position):
        counter = [0] * (self.R + 1)
        for v in self.data:  # 频率计数器，放到下一个位置
            idx = ord(v[position])
            counter[idx + 1] += 1  # 注意是下一个位置
        for r in range(self.R):  # 构造各个类的位置起点
            counter[r + 1] += counter[r]
        for i, v in enumerate(self.data):
            idx = ord(v[position])
            self.aux[counter[idx]] = v  # 根据基础位置压入辅助数组
            counter[idx] += 1
        # self.data = self.aux[:]  # 深拷贝方式
        for i in range(self.N):  # 原地方式
            self.data[i] = self.aux[i]

    def sort(self):
        for i in list(range(self.S))[::-1]:
            self.sort_one(i)
        return self


data = ["4PGC938", "2IYE230", "3CI0720", "1ICK750", "1OHV845", "4JZY524", "1ICK750",
        "3CI0720", "1OHV845", "1OHV845", "2RLA629", "2RLA629", "3ATW723"]

print(LSD(data).data)
print(data)  # 查看是否原地
```
#### C.高位优先算法

问题：若数据不是等长的，那么低位优先算法失效。

思路：仍然使用"键索引计数法"，从高位到低位稳定地进行键索引。使用R+2的存储，其中位置1用来对那些已经到末尾的字符串进行计数，这样这些数据是处于优先。在对每位进行排序时，相当于划分了快排的不同partition，然后在各个partition中仍然需要对下一位排序，若一个partition中的数据较小，应该改用插入排序。因为若对这个partition再次使用"键索引"的开销很大，远远不如插入排序。最坏的情况是每一位都是等值键，那么总是启用"键索引"。

复杂度：O(NlogN / logR)，当N较小的时候，R的开销就比较大了。

```python
# coding=utf-8

class MSD:
    def __init__(self, data):
        self.R = 256
        self.threshold = 0
        self.data = data
        self.N = len(data)
        self.aux = [""] * self.N
        self.msd(0, self.N - 1, 0)

    def get_loc(self, data_i, loc):
        if loc >= len(self.data[data_i]):
            return -1  # 到时候放到counter的1位置
        return ord(self.data[data_i][loc])

    def msd(self, data_lo, data_hi, loc):
        counter = [0] * (self.R + 2)  # 计数器是私有的，不能共享，不然在递归的时候会覆盖 
        # 第lo到hi个数据排序
        if data_hi - data_lo < self.threshold:  # 数据量小时改用（稳定的）插入排序
            return
            # self.insertion_sort()
        for i in range(data_lo, data_hi + 1):  # 频率计数器，放到下一个位置
            idx = self.get_loc(i, loc) + 2
            counter[idx] += 1  # 注意是下一个位置
        for r in range(self.R + 1):  # 构造各个类的位置起点
            counter[r + 1] += counter[r]
        for i in range(data_lo, data_hi + 1):
            idx = self.get_loc(i, loc) + 1
            self.aux[counter[idx]] = self.data[i]  # 根据基础位置压入辅助数组
            counter[idx] += 1
        for i in range(data_lo, data_hi + 1):  # 拷贝回去
            self.data[i] = self.aux[i - data_lo]  # 数据在前面了，因为counter里的数据量统计data_lo到data_hi之间的
        for i in range(self.R):  # 类似快排，在loc位置排好了切分开，每个小组按loc+1的位置排序
            delta = counter[i + 1] - counter[i]
            if delta < 2: continue
            self.msd(data_lo + counter[i], data_lo + counter[i + 1] - 1, loc + 1)


def case():
    data = ["she", "sells", "seashells", "by", "the", "seahore",
            "the", "shells", "she", "sells", "are", "surely", "seashells"]
    MSD(data)
    print(data)


case()
```

缺点：重复前缀多的时候就算有小partition的插排优化，仍然可能创建大量的辅助计数器数组，开销很大。重复问题的一个思路是三路快排。

#### D.(高位优先)的三路快排

解决重复值带来的问题，仍然是从高到低三路(三个partition，哨兵值占一个partition)快排。但是会不稳定。

```python
# coding=utf-8

class Way3:
    def __init__(self, data):
        self.R = 256
        self.threshold = 0
        self.data = data
        self.N = len(data)
        self.aux = [""] * self.N
        self.way3(0,self.N-1,0)

    def get_key(self, data_i, loc):
        # 用来进行前后顺序比较，-1是最优的顺序，表示不够长了
        return ord(self.data[data_i][loc]) if loc < len(self.data[data_i]) else -1

    def way3(self, data_lo, data_hi, loc):
        if data_hi <= data_lo:return
        # lt维护左侧边界，gt维护右侧边界，i是自左至右扫描的指针，dog是哨兵的值
        lt, gt , i, dog = data_lo,data_hi,data_lo+1, self.get_key(data_lo,loc)
        while i <= gt:
            # 保证lt和gt闭区间的值是dog
            key = self.get_key(i,loc)
            if key < dog:  # 左侧边界dog前进
                self.data[i],self.data[lt] = self.data[lt],self.data[i]
                i += 1
                lt += 1
            elif key > dog:  # 右侧边界dog后退
                self.data[i],self.data[gt] = self.data[gt],self.data[i]
                gt -= 1
            else:  # dog前进，去逼近右侧
                i += 1
        self.way3(data_lo,lt-1,loc)
        if dog > -1: self.way3(lt,gt,loc+1)  # 若字符串都不够长了，那么后面可能也无法继续partition了
        self.way3(gt+1,data_hi,loc)


def case():
    data = ["she", "sells", "seashells", "by", "the", "seahore",
            "the", "shells", "she", "sells", "are", "surely", "seashells"]
    Way3(data)
    print(data)


case()
```

#### Z.字符串排序算法的性能对比

| 算法        | 是否稳定 | 是否原地 | 时间复杂度     | 空间复杂度  | 应用场景         |
| --------- | ---- | ---- | --------- | ------ | ------------ |
| 插排        | 是    | 是    | N到N^2     | 1      | 小数组或大量有序的数组  |
| 快排        | 否    | 是    | N(logN)^2 | logN   | 通用，适合空间不足的情况 |
| 归并        | 是    | 否    | N(logN)^2 | N      | 稳定通用         |
| 三路快排      | 否    | 是    | N到NlogN   | logN   | 大量重复键        |
| 低位优先字符串排序 | 是    | 否    | NW        | N      | 较短定长字符串      |
| 高位优先字符串排序 | 是    | 否    | N到Nw之间    | N+WR   | 随机字符串        |
| 高位优先三路快排  | 否    | 是    | N到Nw之间    | W+logN | 通用，且适合大量公共前缀 |

注：N是数据量，W是最大长度，w是平均长度，R是字符集大小。

